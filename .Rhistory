grid.arrange(p1,p3,p2,p4,ncol = 2)
dev.off()
p4
p4 = ggplot(Nd.long, aes(x = durDif, y = SNPsPerKb)) +
geom_point(alpha = 0.25, shape = 1, position = position_jitter(w = 0.1)) +
geom_smooth(method = "lm", linetype = 2, color = "black") +
labs(x = "Difference in infestation duration (years)", y = "", title = "d") +
scale_y_continuous(breaks = c(1,4,7,10)) +
annotate(
geom = "text",
label = expr(paste("Mantel r = ", !!Nd.dur.mantel.stat, ", ", italic("P"), " = ", !!Nd.dur.mantel.sig)),
x = 69,
y = 0.75
) +
my_gg_theme.def_size +
theme(
plot.title = element_text(hjust = -0.04, vjust = -1),
#axis.title.y = element_blank(),
axis.text.y = element_blank()
)
p4
p4 = ggplot(Nd.long, aes(x = durDif, y = SNPsPerKb)) +
geom_point(alpha = 0.25, shape = 1, position = position_jitter(w = 0.1)) +
geom_smooth(method = "lm", linetype = 2, color = "black") +
labs(x = "Difference in infestation duration (years)", y = "", title = "c") +
scale_y_continuous(breaks = c(1,4,7,10)) +
annotate(
geom = "text",
label = expr(paste("Mantel r = ", !!Nd.dur.mantel.stat, ", ", italic("P"), " = ", !!Nd.dur.mantel.sig)),
x = 69,
y = 0.75
) +
my_gg_theme.def_size +
theme(
plot.title = element_text(hjust = -0.04, vjust = -1),
#axis.title.y = element_blank(),
axis.text.y = element_blank()
)
p4
p4 = ggplot(Nd.long, aes(x = durDif, y = SNPsPerKb)) +
geom_point(alpha = 0.25, shape = 1, position = position_jitter(w = 1)) +
geom_smooth(method = "lm", linetype = 2, color = "black") +
labs(x = "Difference in infestation duration (years)", y = "", title = "d") +
scale_y_continuous(breaks = c(1,4,7,10)) +
annotate(
geom = "text",
label = expr(paste("Mantel r = ", !!Nd.dur.mantel.stat, ", ", italic("P"), " = ", !!Nd.dur.mantel.sig)),
x = 69,
y = 0.75
) +
my_gg_theme.def_size +
theme(
plot.title = element_text(hjust = -0.04, vjust = -1),
#axis.title.y = element_blank(),
axis.text.y = element_blank()
)
p4
p4 = ggplot(Nd.long, aes(x = durDif, y = SNPsPerKb)) +
geom_point(alpha = 0.25, shape = 1) +
geom_smooth(method = "lm", linetype = 2, color = "black") +
labs(x = "Difference in infestation duration (years)", y = "", title = "d") +
scale_y_continuous(breaks = c(1,4,7,10)) +
annotate(
geom = "text",
label = expr(paste("Mantel r = ", !!Nd.dur.mantel.stat, ", ", italic("P"), " = ", !!Nd.dur.mantel.sig)),
x = 69,
y = 0.75
) +
my_gg_theme.def_size +
theme(
plot.title = element_text(hjust = -0.04, vjust = -1),
#axis.title.y = element_blank(),
axis.text.y = element_blank()
)
p4
p1 = ggplot(Nf.long, aes(x = km, y = SNPsPerKb)) +
geom_point(alpha = 0.16, shape = 1) +
geom_smooth(method = "lm", linetype = 1, color = "white", linewidth = 2) +
geom_smooth(method = "lm", linetype = 1, color = "black") +
scale_y_continuous(breaks = c(3,4,5)) +
labs(x = "Geographic distance (km)", y = "Hamming distance (SNPs per Kb)", title = "a") +
annotate(
geom = "text",
label = expr(paste("Mantel r = ", !!Nf.geo.mantel.stat, ", ", italic("P"), " = ", !!Nf.geo.mantel.sig)),
x = 1475,
y = 2.5
) +
my_gg_theme.def_size +
theme(
plot.title = element_text(hjust = -0.10, vjust = -1),
axis.title.x = element_blank()
)
p3 = ggplot(Nf.long, aes(x = durDif, y = SNPsPerKb)) +
geom_point(alpha = 0.16, shape = 1) +
geom_smooth(method = "lm", linetype = 1, color = "white", linewidth = 2) +
geom_smooth(method = "lm", linetype = 1, color = "black") +
labs(x = "Difference in infestation duration (years)", y = "", title = "b") +
annotate(
geom = "text",
label = expr(paste("Mantel r = ", !!Nf.dur.mantel.stat, ", ", italic("P"), " = ", !!Nf.dur.mantel.sig)),
x = 61,
y = 2.5
) +
scale_y_continuous(breaks = c(2,3,4,5)) +
my_gg_theme.def_size +
theme(
plot.title = element_text(hjust = -0.04, vjust = -1),
#axis.title.y = element_blank(),
axis.text.y = element_blank(),
axis.title.x = element_blank()
)
pdf("figures/pop_gen/IBD/IBD_durationInfection.four_panel.pdf", width = 10, height = 7)
grid.arrange(p1,p3,p2,p4,ncol = 2)
dev.off()
Nf.Dgeo.long %>% filter(Var1 == "NG121" & Var2 == "NG4")
Nf.Dgeo.long %>% filter(Var1 == "NG4" & Var2 == "NG121")
library(dplyr)
library(ggplot2)
library(gridExtra)
library(vegan)
library(geosphere)
source("library/ggplot_theme.txt")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
sample_metadata = rbind(sample_metadata.Nf %>% filter(collection_period == "modern"),
sample_metadata.Nd %>% filter(collection_period == "modern")
) %>% select(duration_infection, lat, lon, state) %>%
distinct
Dgeo = distm(x = sample_metadata[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = sample_metadata$state
colnames(Dgeo) = sample_metadata$state
Ddur = dist(x = sample_metadata$duration_infection) %>% as.matrix
rownames(Ddur) = sample_metadata$state
colnames(Ddur) = sample_metadata$state
mantel(Ddur, Dgeo)
Dgeo.long = reshape2::melt(Dgeo)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.long = reshape2::melt(Ddur)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
Dgeo.long %>% filter(Var1 == "NH.CCM" & Var2 == "QC.OUC")
Dgeo.long %>% filter(Var2 == "NH.CCM" & Var1 == "QC.OUC")
sample_metadata$state %N% nrow()
sample_metadata$state %n% length()
sample_metadata$state %>% length()
sample_metadata$state %>% unique() %>% length()
sample_metadata$state
sample_metadata.Nd
sample_metadata.Nf
sample_metadata
sample_metadata[-28,]
#We get rid of one NH.CCM row because the Nf and Nd collections have slightly different coords
sample_metadata = sample_metadata[-28,]
sample_metadata$state %>% length()
sample_metadata$state %>% unique() %>% length()
Dgeo = distm(x = sample_metadata[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = sample_metadata$state
colnames(Dgeo) = sample_metadata$state
Ddur = dist(x = sample_metadata$duration_infection) %>% as.matrix
rownames(Ddur) = sample_metadata$state
colnames(Ddur) = sample_metadata$state
mantel(Ddur, Dgeo)
Dgeo.long = reshape2::melt(Dgeo)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.long = reshape2::melt(Ddur)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
library(dplyr)
library(ggplot2)
library(gridExtra)
library(vegan)
library(geosphere)
source("library/ggplot_theme.txt")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
sample_metadata = rbind(sample_metadata.Nf %>% filter(collection_period == "modern"),
sample_metadata.Nd %>% filter(collection_period == "modern")
) %>% select(duration_infection, lat, lon, state) %>%
distinct
#We get rid of one NH.CCM row because the Nf and Nd collections have slightly different coords
sample_metadata = sample_metadata[-28,]
sample_metadata$state %>% length()
sample_metadata$state %>% unique() %>% length()
Dgeo = distm(x = sample_metadata[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = sample_metadata$state
colnames(Dgeo) = sample_metadata$state
Ddur = dist(x = sample_metadata$duration_infection) %>% as.matrix
rownames(Ddur) = sample_metadata$state
colnames(Ddur) = sample_metadata$state
mantel(Ddur, Dgeo)
Dgeo.long = reshape2::melt(Dgeo)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.long = reshape2::melt(Ddur)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
Dgeo.long %>% filter(Var1 == "NH.CCM" & Var2 == "QC.OUC")
Dgeo.long %>% filter(Var2 == "NH.CCM" & Var1 == "QC.OUC")
library(dplyr)
library(ggplot2)
library(gridExtra)
library(vegan)
library(geosphere)
source("library/ggplot_theme.txt")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
sample_metadata = rbind(sample_metadata.Nf %>% filter(collection_period == "modern"),
sample_metadata.Nd %>% filter(collection_period == "modern")
) %>% select(duration_infection, lat, lon, state) %>%
distinct
#We get rid of one NH.CCM row because the Nf and Nd collections have slightly different coords
sample_metadata = sample_metadata[-28,]
sample_metadata$state %>% length()
sample_metadata$state %>% unique() %>% length()
Dgeo = distm(x = sample_metadata[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = sample_metadata$state
colnames(Dgeo) = sample_metadata$state
Ddur = dist(x = sample_metadata$duration_infection) %>% as.matrix
rownames(Ddur) = sample_metadata$state
colnames(Ddur) = sample_metadata$state
#we are not naming by state because there are two QC.OU sites with different coords
#this is because there is one for Nf and one for Nd
mantel(Ddur, Dgeo)
#Mantel statistic r:     0.7499
#Significance: 0.001
Dgeo.mat = Dgeo %>% as.matrix
diag(Dgeo.mat) = NA
Dgeo.mat[upper.tri(Dgeo.mat)] = NA
Dgeo.long = reshape2::melt(Dgeo)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.mat = Ddur %>% as.matrix
diag(Ddur.mat) = NA
Ddur.mat[upper.tri(Ddur.mat)] = NA
Ddur.long = reshape2::melt(Ddur)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
Dgeo.long %>% filter(Var1 == "NH.CCM" & Var2 == "QC.OUC")
Dgeo.long %>% filter(Var2 == "NH.CCM" & Var1 == "QC.OUC")
Dgeo.long = reshape2::melt(Dgeo.mat)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.long = reshape2::melt(Ddur.mat)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
Dgeo.long %>% filter(Var1 == "NH.CCM" & Var2 == "QC.OUC")
Dgeo.long %>% filter(Var2 == "NH.CCM" & Var1 == "QC.OUC")
p1 = ggplot(full_dat, aes(x = km, y = durDif)) +
geom_point(alpha = 0.25, shape = 1) +
#geom_smooth(method = "lm", linetype = 1, color = "white", linewidth = 2) +
geom_smooth(method = "lm", linetype = 1, color = "black") +
labs(x = "Geographic distance (km)", y = "Difference in infestation duration (years)") +
annotate(
geom = "text",
label = expression(paste("Mantel r = 0.74,", italic("P"), " = 0.001")),
x = 1750,
y = 2.5
) +
my_gg_theme.def_size
p1
p1 = ggplot(full_dat, aes(x = km, y = durDif)) +
geom_point(alpha = 0.5, shape = 1) +
#geom_smooth(method = "lm", linetype = 1, color = "white", linewidth = 2) +
geom_smooth(method = "lm", linetype = 1, color = "black") +
labs(x = "Geographic distance (km)", y = "Difference in infestation duration (years)") +
annotate(
geom = "text",
label = expression(paste("Mantel r = 0.75,", italic("P"), " = 0.001")),
x = 1750,
y = 2.5
) +
my_gg_theme.def_size
p1
pdf("figures/pop_gen/IBD/geo_v_infestation_duration.pdf", width = 6.5, height = 3.5)
p1
dev.off()
q(save="no")
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
#vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
keep.ind.list = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states))
keep.ind.list
distances.list = list()
#based on the lowest number of samples to include sites
min_samps = 3
u = 1
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
pops_incl
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand
keep.ind.rand.df = bind_rows(keep.ind.rand)
keep.ind.rand.df
nrow(keep.ind.rand.df)
gl.subset = gl[gl@ind.names %in% keep.ind.rand.df$gl.ind.names]
gl.subset
#First convert to a data.frame which will give a table of 0, 1, NA, and then add 1 to values to have correct conversion of NA (0 is default)
y = as.data.frame(gl.subset)
y
head(y)
nrow(y)
ncol(y)
rownames(y)
gi = df2genind(y + 1, ploidy=1)
gl@ind.names
keep.ind.rand.df
gl[c(1,1,2,1),]
gl[,c(1,1,2,1)]
gl[c(1,1,2,1),drop=T]
gi
gi[c(1,1,2,1),drop=T]
?genind2genpop
NA + 1
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(glc(1,1,2,1),drop=T)
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,1,2,1),drop=T])
y
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,2),c(2,3),drop=F])
y
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,2),c(1:10),drop=F])
y
gl[c(1,2),c(1:10),drop=F]
gl[c(1,2),c(10:20),drop=F]
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,2),c(10:20),drop=F])
y
y + 1
gi = df2genind(y + 1, ploidy=1)
gi
gi@tab
gi = df2genind(y, ploidy=1)
gi@tab
gp = genind2genpop(gi)
gi@pop = gl@pop
gp = genind2genpop(gi)
gi@pop = c(1,2)#gl@pop
gi
gi@pop = c("a","b")
gl
keep.ind.list
system.time(
y = as.data.frame(gl)
gi = df2genind(y+1, ploidy=1)
start.time <- Sys.time()
y = as.data.frame(gl)
gi = df2genind(y+1, ploidy=1)
gi@pop = gl@pop
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#run the bootstrapping
start.time <- Sys.time()
n_boots = 1
for(u in 1:n_boots){
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand.df = bind_rows(keep.ind.rand)
##########################################
# take subset. the drop = T removes invariable loci
gi.subset = gi[keep.ind.rand.df, drop = T]
gp = genind2genpop(gi.subset.rm)
#There are several distance metrics available
#Method 2 is "Angular distance or Edward's distance" D[CSE]
Dgen.2 <- dist.genpop(gp,method=2)
distances.list[[u]] = Dgen.2
}
u =1
u
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand.df = bind_rows(keep.ind.rand)
keep.ind.rand.df
# take subset. the drop = T removes invariable loci
gi.subset = gi[keep.ind.rand.df$pop.gl, drop = T]
# take subset. the drop = T removes invariable loci
gi.subset = gi[keep.ind.rand.df$gl.ind.names, drop = T]
gi.subset
gi.subset@tab[1,]
gi.subset@loc.n.all
names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ]) %>% length
names(gi.subset@loc.n.all[gi.subset@loc.n.all == 2 ]) %>% length
gi.subset
gi.subset.rm = gi.subset[loc=-names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])]
to_remove = names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
gi.subset.rm = gi.subset[loc=-to_remove]
gi.subset.rm = gi.subset[,-to_remove]
gi.subset.rm = gi.subset[loc=-c(1,2,3)]
gi.subset
which(gi.subset@loc.names %in% to_remove)
gi.subset@loc
gi.subset@all.names
gi.subset@all.names %>% str
str(names(gi.subset@loc.n.all))
names(gi.subset@loc.n.all)
which(names(gi.subset@loc.n.all) %in% to_remove)
names(gi.subset@loc.n.all)
which(names(gi.subset@loc.n.all) %in% to_remove)
rm_indx = which(names(gi.subset@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset[loc=-rm_indx]
gi.subset.rm
length(to_remove)
gi.subset
gi.subset.rm
start.time <- Sys.time()
n_boots = 1
for(u in 1:n_boots){
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand.df = bind_rows(keep.ind.rand)
##########################################
# take subset. the drop = T removes invariable loci
# actually drop = T doesn't seem to work
# still many loci where loc.n.all == 1
gi.subset = gi[keep.ind.rand.df$gl.ind.names]
to_remove = names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
rm_indx = which(names(gi.subset@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
#There are several distance metrics available
#Method 2 is "Angular distance or Edward's distance" D[CSE]
Dgen.2 <- dist.genpop(gp,method=2)
distances.list[[u]] = Dgen.2
}
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nd %>% select(Sequence_label, state, lat, lon)
vcf <- read.vcfR("data/Nd/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
low_n_states
gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n())
q(save="no")
