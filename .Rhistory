#metadata
#sample_metadata.Nf = read.csv("~/Nf_pop_IBD_11182024/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#filtered VCF
#vcf <- read.vcfR("~/Nf_pop_IBD_11182024/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
keep.ind.list = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states))
gl[keep.ind.list, drop = T]
keep.ind.list$gl.ind.names
gl[keep.ind.list$gl.ind.names, drop = T]
keep.ind.list$gl.ind.names
gl[keep.ind.list$gl.ind.names]
#start.time <- Sys.time()
y = as.data.frame(gl)
gi = df2genind(y+1, ploidy=1)
gi@pop = gl@pop
gi.subset = gi[keep.ind.list$gl.ind.names]
to_remove = names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
rm_indx = which(names(gi.subset@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
Dgen.2 <- dist.genpop(gp,method=2)
saveRDS(distances.list, "data/Nf/IBD/Nf.DSCE.no_subsample.rds")
saveRDS(Dgen.2, "data/Nf/IBD/Nf.DSCE.no_subsample.rds")
ind.metrics.subset = ind.metrics %>% filter(Sequence_label %in% keep.ind.list$gl.ind.names)
library(geosphere)
ind.metrics.subset
Dgeo = distm(x = ind.metrics.subset[,c("lon", "lat")], fun = distVincentyEllipsoid)
Dgeo
Dgen.2
site_dat = ind.metrics %>%
filter(!state %in% low_n_states) %>%
select(!Sequence_label) %>%
distinct
site_dat
row.names(site_dat) = site_dat$state
site_dat
Dgen.2
gp@all.names
gp@tab
row.names(gp@tab)
site_dat.ordered = site_dat[row.names(gp@tab),]
site_dat.ordered
Dgeo = distm(x = site_dat.ordered[,c("lon", "lat")], fun = distVincentyEllipsoid)
Dgeo
col.names(Dgeo) = site_dat.ordered$state
rownames(Dgeo) = site_dat.ordered$state
colnames(Dgeo) = site_dat.ordered$state
Dgeo
mantel(Dgen.2, Dgeo)
mantel(Dgen.2, Dgeo)
library(vegan)
mantel(Dgen.2, Dgeo)
Dgeo = Dgeo/1000
mantel(Dgen.2, Dgeo)
Dgeo
#mantel
mantel(Dgen.2, log(Dgeo))
#mantel no VA
Dgeo.noVA = Dgeo[rownames(Dgeo) == "VA"] = NA
Dgeo.noVA
Dgeo
Dgeo = distm(x = site_dat.ordered[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = site_dat.ordered$state
colnames(Dgeo) = site_dat.ordered$state
Dgeo = Dgeo/1000
#mantel no VA
Dgeo.noVA = Dgeo
Dgeo.noVA[rownames(Dgeo.noVA) == "VA"] = NA
Dgeo.noVA
Dgeo.noVA[colnames(Dgeo.noVA) == "VA"] = NA
mantel(Dgen.2, Dgeo.noVA)
?mantel
low_n_states
keep.ind.list
site_dat.ordered
keep.ind.list.no_VA = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(pop.gl != "VA")
gi.subset.no_VA = gi.subset[keep.ind.list.no_VA$gl.ind.names]
to_remove = names(gi.subset.no_VA@loc.n.all[gi.subset.no_VA@loc.n.all == 1 ])
rm_indx = which(names(gi.subset.no_VA@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset.no_VA[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
Dgen.2 <- dist.genpop(gp,method=2)
keep.ind.list.no_VA = data.frame(gl.subset@ind.names, pop.gl = pop(gl)) %>% filter(pop.gl != "VA")
keep.ind.list.no_VA = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states, "VA"))
gi.subset.no_VA = gi.subset[keep.ind.list.no_VA$gl.ind.names]
to_remove = names(gi.subset.no_VA@loc.n.all[gi.subset.no_VA@loc.n.all == 1 ])
rm_indx = which(names(gi.subset.no_VA@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset.no_VA[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
Dgen.2 <- dist.genpop(gp,method=2)
site_dat.no_VA = ind.metrics %>%
filter(!state %in% c(low_n_states, "VA")) %>%
select(!Sequence_label) %>%
distinct
row.names(site_dat.no_VA) = site_dat.no_VA$state
site_dat.ordered = site_dat[row.names(gp@tab),]
Dgeo = distm(x = site_dat.ordered[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = site_dat.ordered$state
colnames(Dgeo) = site_dat.ordered$state
Dgeo = Dgeo/1000
mantel(Dgen.2, Dgeo.noVA)
mantel(Dgen.2, Dgeo)
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
#sample_metadata.Nf = read.csv("~/Nf_pop_IBD_11182024/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
#filtered VCF
#vcf <- read.vcfR("~/Nf_pop_IBD_11182024/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
min_samps = 4
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < min_samps) )$state
low_n_states
keep.ind.list = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states))
keep.ind.list
keep.ind.list$pop.gl %>% unique
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
sample_metadata.Nd = read.csv("~/Nd_pop_IBD_11182024/Nd_filtered.lat_lon_dur_inf.csv")
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
#sample_metadata.Nd = read.csv("~/Nd_pop_IBD_11182024/Nd_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nd %>% select(Sequence_label, state, lat, lon)
#filtered VCF
#vcf <- read.vcfR("~/Nd_pop_IBD_11182024/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
vcf <- read.vcfR("data/Nd/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
q(save="no")
q(save="no")
library(dplyr)
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
library(vcfR)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
sample_metadata.Nf %>% head
sample_metadata.Nf %>% pull(Sequence_label, state)
sample_metadata.Nf %>% select(Sequence_label, state)
write.table((sample_metadata.Nf %>% select(Sequence_label, state)), "data/sample_metadata/Nf.pixy_pops.tsv", sep = "\t", col.names = F, row.names = F, quote = F)
q(save="no")
q(save="no")
library(snpR)
install.packages("snpR")
remotes::install_github("hemstrow/snpR")
library(snpR)
library(vcfR)
library(adegenet)
library(snpR)
library(dplyr)
q(save="no")
library(dplyr)
library(vcfR)
library(adegenet)
library(snpR)
#metadata
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
colnames(ind.metrics) = c("sampID", "pop", "lat", "lon")
sub("\\.", "_", ind.metrics$pop) -> ind.metrics$pop #snpR does not accept .s ... beyond annoying
row.names(ind.metrics) = ind.metrics$sampID
#filtered VCF
# bialleles only
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.biallele.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
rm(vcf)
gc()
#Set metadata in genLight
#gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[gl@ind.names,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics[gl@ind.names,"pop"]) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
gl2 = dartR::gl.recalc.metrics(gl)
install.packages("dartR")
gl2 = dartR::gl.recalc.metrics(gl)
library(dartR)
gl2 = dartR::gl.recalc.metrics(gl)
install.packages("SNPRelate")
BiocManager::install("SNPRelate")
gl2 = dartR::gl.recalc.metrics(gl)
gl
#filtered VCF
# bialleles only
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.mac_ge2.biallele.gwas_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
rm(vcf)
gc()
#Set metadata in genLight
#gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[gl@ind.names,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics[gl@ind.names,"pop"]) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
dat = convert_genlight(gl) #try this, the above is REALLY slow
# Processed 1219548 groups out of 1219548
rm(gl)
gc()
dat
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = "pop",
sigma = 10, #sliding window size in kb
step = 20, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = F #use this to just calculate global
)
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = pop,
sigma = 10, #sliding window size in kb
step = 20, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = F #use this to just calculate global
)
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = "pop",
sigma = 100, #sliding window size in kb
step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = F #use this to just calculate global
)
vcf
vcf = snpR::read_vcf("data/Nf/final_tables/rm_dups/FINAL_snp.biallele.vcf.gz")
#filtered VCF
# bialleles only
# we are now also excluding singletons bc this was causing problems with the conversion to snpR
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.mac_ge2.biallele.gwas_analyses.vcf.gz", verbose = FALSE)
vcf
?read_vcf
?read.vcfR
vcf
rm(vcf)
gc()
vcf = snpR::read_vcf("data/Nf/final_tables/rm_dups/FINAL_snp.biallele.no_qual.vcf.gz")
?snpR::read_vcf
vcf = snpR::read_vcf("data/Nf/final_tables/rm_dups/FINAL_snp.biallele.snpR.vcf.gz")
vcf = snpR::read_vcf("data/Nf/final_tables/rm_dups/FINAL_snp.biallele.snpR.vcf.gz")
vcf = snpR::read_vcf("data/Nf/final_tables/rm_dups/FINAL_snp.biallele.snpR.vcf.gz", header_cols = 4)
#filtered VCF
# bialleles only
# we are now also excluding singletons bc this was causing problems with the conversion to snpR
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.mac_ge2.biallele.gwas_analyses.vcf.gz", verbose = FALSE)
gt = extract.gt(vcf, element='GT', as.numeric=TRUE)
vcf.info = INFO2df(vcf)
head(vcf.info)
head(gt)
?strsplit
?strsplit
strsplit(row.names(gt), "_")
gt.pos_list = strsplit(row.names(gt), "_")
gt.pos_df = data.frame(
CHROM = paste(
lapply(gt.pos_list, function(x) x[1]) %>% unlist,
lapply(gt.pos_list, function(x) x[2]) %>% unlist,
sep = "_"
),
POS = lapply(gt.pos_list, function(x) x[3]) %>% unlist,
stringsAsFactors = F
)
gt.pos_df
nrow(gt)
nrow(gt.pos_df)
is.data.frame(gt)
class(gt)
as.data.frame(gt) %>% head
?import.snpR.data
head(ind.metrics)
dat = import.snpR.data(as.data.frame(gt), snp.meta = gt.pos_df, sample.meta = ind.metrics)
gt[is.na(gt)] = NA
gt[is.na(gt)] = "NN"
head(gt)
dat = import.snpR.data(as.data.frame(gt), snp.meta = gt.pos_df, sample.meta = ind.metrics)
dat
gt = extract.gt(vcf, element='GT', as.numeric=TRUE)
gt = data.frame(gt)
gt[is.na(gt)] = "NN"
head(gt)
dat = import.snpR.data(gt, snp.meta = gt.pos_df, sample.meta = ind.metrics)
dat
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = "pop",
sigma = 100, #sliding window size in kb
step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = F #use this to just calculate global
)
gt.pos_df = data.frame(
chr = paste(
lapply(gt.pos_list, function(x) x[1]) %>% unlist,
lapply(gt.pos_list, function(x) x[2]) %>% unlist,
sep = "_"
),
position = lapply(gt.pos_list, function(x) x[3]) %>% unlist,
stringsAsFactors = F
) #note these column names must be chr and position for snpR
?calc_tajimas_d
dat = import.snpR.data(gt, snp.meta = gt.pos_df, sample.meta = ind.metrics)
dat
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = "pop",
sigma = 100, #sliding window size in kb
step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = F #use this to just calculate global
)
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
#facets = c("pop", "chr"),
#sigma = 100, #sliding window size in kb
#step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
#triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = T #use this to just calculate global
)
dat
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = c("pop"),
#sigma = 100, #sliding window size in kb
#step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
#triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = T #use this to just calculate global
)
get.snpR.stats(dat)
?get.snpR.stats
get.snpR.stats(dat, stats = "calc_tajimas_d")
get.snpR.stats(dat, stats = "tajimas_d")
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = c("pop"),
#sigma = 100, #sliding window size in kb
#step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
#triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = T #use this to just calculate global
)
get.snpR.stats(dat, stats = "tajimas_d", facets = c("pop"))
get.snpR.stats(dat, stats = "global_tajimas_d", facets = c("pop"))
get.snpR.stats(dat, stats = "tajimas_d", facets = c("pop"))
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
calc_tajimas_d(
dat,
facets = c("pop", "chr"),
sigma = 100, #sliding window size in kb
step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = F #use this to just calculate global
)
get.snpR.stats(dat, stats = "tajimas_d", facets = c("pop"))
get.snpR.stats(dat, stats = "tajimas_d", facets = c("pop", "chr"))
get.snpR.stats(dat, stats = "tajimas_d")
get.snpR.stats(dat, "pop")
get.snpR.stats(dat, "pop", "tajimas_d")
get.snpR.stats(dat)
foo = get.snpR.stats(dat)
str(foo)
#bi-allelic snpRdata with 424811 SNPs and 115 samples.
#Calculated statistics can be accessed via get.snpR.stats()
#
# note that this is about half of the SNPs we get when including mac==1
#
foo = calc_tajimas_d(
dat,
facets = c("pop", "chr"),
#sigma = 100, #sliding window size in kb
#step = 200, #defulat = sigma*2 (non-overlapping windows)
par = 5, #number cores
#triple_sigma = F, #this is for smoothing, calcualtes average in window of 3xsigma
global = T #use this to just calculate global
)
foo
get.snpR.stats(dat, "chr.pop", "tajimas_d")
get.snpR.stats(dat, "chr.pop", "global_tajimas_d")
get.snpR.stats(dat, "chr.pop", "global_tajimas_d")
str(foo)
get.snpR.stats(dat, "chr.pop", "global_D")
get.snpR.stats(dat, "chr.pop", "tajimas_D")
get.snpR.stats(dat, "weighted.means")
get.snpR.stats(dat, stat = "weighted.means")
foo@weighted.means
q(save="no")
