sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
sample_metadata = rbind(sample_metadata.Nf %>% filter(collection_period == "modern"),
sample_metadata.Nd %>% filter(collection_period == "modern")
) %>% select(duration_infection, lat, lon, state) %>%
distinct
#We get rid of one NH.CCM row because the Nf and Nd collections have slightly different coords
sample_metadata = sample_metadata[-28,]
sample_metadata$state %>% length()
sample_metadata$state %>% unique() %>% length()
Dgeo = distm(x = sample_metadata[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = sample_metadata$state
colnames(Dgeo) = sample_metadata$state
Ddur = dist(x = sample_metadata$duration_infection) %>% as.matrix
rownames(Ddur) = sample_metadata$state
colnames(Ddur) = sample_metadata$state
#we are not naming by state because there are two QC.OU sites with different coords
#this is because there is one for Nf and one for Nd
mantel(Ddur, Dgeo)
#Mantel statistic r:     0.7499
#Significance: 0.001
Dgeo.mat = Dgeo %>% as.matrix
diag(Dgeo.mat) = NA
Dgeo.mat[upper.tri(Dgeo.mat)] = NA
Dgeo.long = reshape2::melt(Dgeo)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.mat = Ddur %>% as.matrix
diag(Ddur.mat) = NA
Ddur.mat[upper.tri(Ddur.mat)] = NA
Ddur.long = reshape2::melt(Ddur)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
Dgeo.long %>% filter(Var1 == "NH.CCM" & Var2 == "QC.OUC")
Dgeo.long %>% filter(Var2 == "NH.CCM" & Var1 == "QC.OUC")
Dgeo.long = reshape2::melt(Dgeo.mat)
Dgeo.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
Ddur.long = reshape2::melt(Ddur.mat)
Ddur.long %>% filter(Var1 == "NY.N" & Var2 == "NY.S")
colnames(Dgeo.long)[3] = "km"
Dgeo.long$km = Dgeo.long$km/1000
colnames(Ddur.long)[3] = "durDif"
full_dat = left_join(Dgeo.long, Ddur.long, by = c("Var1", "Var2"))
Dgeo.long %>% filter(Var1 == "NH.CCM" & Var2 == "QC.OUC")
Dgeo.long %>% filter(Var2 == "NH.CCM" & Var1 == "QC.OUC")
p1 = ggplot(full_dat, aes(x = km, y = durDif)) +
geom_point(alpha = 0.25, shape = 1) +
#geom_smooth(method = "lm", linetype = 1, color = "white", linewidth = 2) +
geom_smooth(method = "lm", linetype = 1, color = "black") +
labs(x = "Geographic distance (km)", y = "Difference in infestation duration (years)") +
annotate(
geom = "text",
label = expression(paste("Mantel r = 0.74,", italic("P"), " = 0.001")),
x = 1750,
y = 2.5
) +
my_gg_theme.def_size
p1
p1 = ggplot(full_dat, aes(x = km, y = durDif)) +
geom_point(alpha = 0.5, shape = 1) +
#geom_smooth(method = "lm", linetype = 1, color = "white", linewidth = 2) +
geom_smooth(method = "lm", linetype = 1, color = "black") +
labs(x = "Geographic distance (km)", y = "Difference in infestation duration (years)") +
annotate(
geom = "text",
label = expression(paste("Mantel r = 0.75,", italic("P"), " = 0.001")),
x = 1750,
y = 2.5
) +
my_gg_theme.def_size
p1
pdf("figures/pop_gen/IBD/geo_v_infestation_duration.pdf", width = 6.5, height = 3.5)
p1
dev.off()
q(save="no")
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
#vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
keep.ind.list = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states))
keep.ind.list
distances.list = list()
#based on the lowest number of samples to include sites
min_samps = 3
u = 1
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
pops_incl
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand
keep.ind.rand.df = bind_rows(keep.ind.rand)
keep.ind.rand.df
nrow(keep.ind.rand.df)
gl.subset = gl[gl@ind.names %in% keep.ind.rand.df$gl.ind.names]
gl.subset
#First convert to a data.frame which will give a table of 0, 1, NA, and then add 1 to values to have correct conversion of NA (0 is default)
y = as.data.frame(gl.subset)
y
head(y)
nrow(y)
ncol(y)
rownames(y)
gi = df2genind(y + 1, ploidy=1)
gl@ind.names
keep.ind.rand.df
gl[c(1,1,2,1),]
gl[,c(1,1,2,1)]
gl[c(1,1,2,1),drop=T]
gi
gi[c(1,1,2,1),drop=T]
?genind2genpop
NA + 1
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(glc(1,1,2,1),drop=T)
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,1,2,1),drop=T])
y
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,2),c(2,3),drop=F])
y
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,2),c(1:10),drop=F])
y
gl[c(1,2),c(1:10),drop=F]
gl[c(1,2),c(10:20),drop=F]
# the format conversions are the longest running bits. Pull as much out of the loop as possible
# gl2df -> add 1 -> df2gi
y = as.data.frame(gl[c(1,2),c(10:20),drop=F])
y
y + 1
gi = df2genind(y + 1, ploidy=1)
gi
gi@tab
gi = df2genind(y, ploidy=1)
gi@tab
gp = genind2genpop(gi)
gi@pop = gl@pop
gp = genind2genpop(gi)
gi@pop = c(1,2)#gl@pop
gi
gi@pop = c("a","b")
gl
keep.ind.list
system.time(
y = as.data.frame(gl)
gi = df2genind(y+1, ploidy=1)
start.time <- Sys.time()
y = as.data.frame(gl)
gi = df2genind(y+1, ploidy=1)
gi@pop = gl@pop
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
#run the bootstrapping
start.time <- Sys.time()
n_boots = 1
for(u in 1:n_boots){
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand.df = bind_rows(keep.ind.rand)
##########################################
# take subset. the drop = T removes invariable loci
gi.subset = gi[keep.ind.rand.df, drop = T]
gp = genind2genpop(gi.subset.rm)
#There are several distance metrics available
#Method 2 is "Angular distance or Edward's distance" D[CSE]
Dgen.2 <- dist.genpop(gp,method=2)
distances.list[[u]] = Dgen.2
}
u =1
u
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand.df = bind_rows(keep.ind.rand)
keep.ind.rand.df
# take subset. the drop = T removes invariable loci
gi.subset = gi[keep.ind.rand.df$pop.gl, drop = T]
# take subset. the drop = T removes invariable loci
gi.subset = gi[keep.ind.rand.df$gl.ind.names, drop = T]
gi.subset
gi.subset@tab[1,]
gi.subset@loc.n.all
names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ]) %>% length
names(gi.subset@loc.n.all[gi.subset@loc.n.all == 2 ]) %>% length
gi.subset
gi.subset.rm = gi.subset[loc=-names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])]
to_remove = names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
gi.subset.rm = gi.subset[loc=-to_remove]
gi.subset.rm = gi.subset[,-to_remove]
gi.subset.rm = gi.subset[loc=-c(1,2,3)]
gi.subset
which(gi.subset@loc.names %in% to_remove)
gi.subset@loc
gi.subset@all.names
gi.subset@all.names %>% str
str(names(gi.subset@loc.n.all))
names(gi.subset@loc.n.all)
which(names(gi.subset@loc.n.all) %in% to_remove)
names(gi.subset@loc.n.all)
which(names(gi.subset@loc.n.all) %in% to_remove)
rm_indx = which(names(gi.subset@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset[loc=-rm_indx]
gi.subset.rm
length(to_remove)
gi.subset
gi.subset.rm
start.time <- Sys.time()
n_boots = 1
for(u in 1:n_boots){
keep.ind.rand = list()
pops_incl = keep.ind.list$pop.gl %>% as.character %>% unique
#select min_samps random samples from each site for distance calc
for(i in 1:length(pops_incl)){
temp = keep.ind.list %>% filter(pop.gl == pops_incl[i])
keep.ind.rand[[pops_incl[i]]] = temp[sample(1:nrow(temp), min_samps, replace = T),] # random sample of min_samps rows
}
keep.ind.rand.df = bind_rows(keep.ind.rand)
##########################################
# take subset. the drop = T removes invariable loci
# actually drop = T doesn't seem to work
# still many loci where loc.n.all == 1
gi.subset = gi[keep.ind.rand.df$gl.ind.names]
to_remove = names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
rm_indx = which(names(gi.subset@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
#There are several distance metrics available
#Method 2 is "Angular distance or Edward's distance" D[CSE]
Dgen.2 <- dist.genpop(gp,method=2)
distances.list[[u]] = Dgen.2
}
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nd %>% select(Sequence_label, state, lat, lon)
vcf <- read.vcfR("data/Nd/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
low_n_states
gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n())
q(save="no")
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
#sample_metadata.Nf = read.csv("~/Nf_pop_IBD_11182024/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#filtered VCF
#vcf <- read.vcfR("~/Nf_pop_IBD_11182024/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
keep.ind.list = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states))
gl[keep.ind.list, drop = T]
keep.ind.list$gl.ind.names
gl[keep.ind.list$gl.ind.names, drop = T]
keep.ind.list$gl.ind.names
gl[keep.ind.list$gl.ind.names]
#start.time <- Sys.time()
y = as.data.frame(gl)
gi = df2genind(y+1, ploidy=1)
gi@pop = gl@pop
gi.subset = gi[keep.ind.list$gl.ind.names]
to_remove = names(gi.subset@loc.n.all[gi.subset@loc.n.all == 1 ])
rm_indx = which(names(gi.subset@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
Dgen.2 <- dist.genpop(gp,method=2)
saveRDS(distances.list, "data/Nf/IBD/Nf.DSCE.no_subsample.rds")
saveRDS(Dgen.2, "data/Nf/IBD/Nf.DSCE.no_subsample.rds")
ind.metrics.subset = ind.metrics %>% filter(Sequence_label %in% keep.ind.list$gl.ind.names)
library(geosphere)
ind.metrics.subset
Dgeo = distm(x = ind.metrics.subset[,c("lon", "lat")], fun = distVincentyEllipsoid)
Dgeo
Dgen.2
site_dat = ind.metrics %>%
filter(!state %in% low_n_states) %>%
select(!Sequence_label) %>%
distinct
site_dat
row.names(site_dat) = site_dat$state
site_dat
Dgen.2
gp@all.names
gp@tab
row.names(gp@tab)
site_dat.ordered = site_dat[row.names(gp@tab),]
site_dat.ordered
Dgeo = distm(x = site_dat.ordered[,c("lon", "lat")], fun = distVincentyEllipsoid)
Dgeo
col.names(Dgeo) = site_dat.ordered$state
rownames(Dgeo) = site_dat.ordered$state
colnames(Dgeo) = site_dat.ordered$state
Dgeo
mantel(Dgen.2, Dgeo)
mantel(Dgen.2, Dgeo)
library(vegan)
mantel(Dgen.2, Dgeo)
Dgeo = Dgeo/1000
mantel(Dgen.2, Dgeo)
Dgeo
#mantel
mantel(Dgen.2, log(Dgeo))
#mantel no VA
Dgeo.noVA = Dgeo[rownames(Dgeo) == "VA"] = NA
Dgeo.noVA
Dgeo
Dgeo = distm(x = site_dat.ordered[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = site_dat.ordered$state
colnames(Dgeo) = site_dat.ordered$state
Dgeo = Dgeo/1000
#mantel no VA
Dgeo.noVA = Dgeo
Dgeo.noVA[rownames(Dgeo.noVA) == "VA"] = NA
Dgeo.noVA
Dgeo.noVA[colnames(Dgeo.noVA) == "VA"] = NA
mantel(Dgen.2, Dgeo.noVA)
?mantel
low_n_states
keep.ind.list
site_dat.ordered
keep.ind.list.no_VA = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(pop.gl != "VA")
gi.subset.no_VA = gi.subset[keep.ind.list.no_VA$gl.ind.names]
to_remove = names(gi.subset.no_VA@loc.n.all[gi.subset.no_VA@loc.n.all == 1 ])
rm_indx = which(names(gi.subset.no_VA@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset.no_VA[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
Dgen.2 <- dist.genpop(gp,method=2)
keep.ind.list.no_VA = data.frame(gl.subset@ind.names, pop.gl = pop(gl)) %>% filter(pop.gl != "VA")
keep.ind.list.no_VA = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states, "VA"))
gi.subset.no_VA = gi.subset[keep.ind.list.no_VA$gl.ind.names]
to_remove = names(gi.subset.no_VA@loc.n.all[gi.subset.no_VA@loc.n.all == 1 ])
rm_indx = which(names(gi.subset.no_VA@loc.n.all) %in% to_remove)
gi.subset.rm = gi.subset.no_VA[loc=-rm_indx]
gp = genind2genpop(gi.subset.rm)
Dgen.2 <- dist.genpop(gp,method=2)
site_dat.no_VA = ind.metrics %>%
filter(!state %in% c(low_n_states, "VA")) %>%
select(!Sequence_label) %>%
distinct
row.names(site_dat.no_VA) = site_dat.no_VA$state
site_dat.ordered = site_dat[row.names(gp@tab),]
Dgeo = distm(x = site_dat.ordered[,c("lon", "lat")], fun = distVincentyEllipsoid)
rownames(Dgeo) = site_dat.ordered$state
colnames(Dgeo) = site_dat.ordered$state
Dgeo = Dgeo/1000
mantel(Dgen.2, Dgeo.noVA)
mantel(Dgen.2, Dgeo)
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
#sample_metadata.Nf = read.csv("~/Nf_pop_IBD_11182024/Nf_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nf = read.csv("data/sample_metadata/Nf_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nf %>% select(Sequence_label, state, lat, lon)
#filtered VCF
#vcf <- read.vcfR("~/Nf_pop_IBD_11182024/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
vcf <- read.vcfR("data/Nf/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
min_samps = 4
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < min_samps) )$state
low_n_states
keep.ind.list = data.frame(gl@ind.names, pop.gl = pop(gl)) %>% filter(!pop.gl %in% c(low_n_states))
keep.ind.list
keep.ind.list$pop.gl %>% unique
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
sample_metadata.Nd = read.csv("~/Nd_pop_IBD_11182024/Nd_filtered.lat_lon_dur_inf.csv")
set.seed(12345)
library(vcfR)
library(dplyr)
library(adegenet)
#premise conda env
#mamba create --name R-pop_gen conda-forge::r-tidyr conda-forge::r-dplyr bioconda::r-adegenet bioconda::r-vcfr
#conda activate R-pop_gen
#metadata
#sample_metadata.Nd = read.csv("~/Nd_pop_IBD_11182024/Nd_filtered.lat_lon_dur_inf.csv")
sample_metadata.Nd = read.csv("data/sample_metadata/Nd_filtered.lat_lon_dur_inf.csv")
#########
#prev used table of sample,state.name,lat,lon
ind.metrics = sample_metadata.Nd %>% select(Sequence_label, state, lat, lon)
#filtered VCF
#vcf <- read.vcfR("~/Nd_pop_IBD_11182024/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
vcf <- read.vcfR("data/Nd/final_tables/rm_dups/FINAL_snp.IBD_analyses.vcf.gz", verbose = FALSE)
gl = vcfR2genlight(vcf)
#In vcfR2genlight(vcf) : Found 47046 loci with more than two alleles.
#Objects of class genlight only support loci with two alleles.
#47046 loci will be omitted from the genlight object.
rm(vcf)
gc()
row.names(ind.metrics) = ind.metrics$Sequence_label
#Set metadata in genLight
gl@other$ind.metrics = ind.metrics[gl@ind.names,]
gl@other$latlong = ind.metrics[,3:4]
gl@other$latlong
gl@pop = as.factor(ind.metrics$state) #need to set pop for the ibd test to work
gl@ploidy = rep(as.integer(1), nInd(gl))
#SOME SITES HAVE SMALL SAMPLE SIZE
#Set min sample size to 3
low_n_states = ( (gl@other$ind.metrics %>% group_by(state) %>% summarize(n = n()) ) %>% filter(n < 3) )$state
q(save="no")
q(save="no")
